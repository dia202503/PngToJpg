<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PNG→JPG 変換（安全定義＋JSフォールバック）</title>
  <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <style>
    body{font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP",sans-serif;padding:16px}
    .card{background:#f6f7f9;border-radius:12px;padding:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .log{background:#0b1020;color:#cbd5e1;min-height:200px;white-space:pre-wrap;border-radius:12px;padding:10px}
    button{background:#2563eb;color:#fff;border:none;border-radius:10px;padding:10px 14px;cursor:pointer}
    .secondary{background:#e5e7eb;color:#111}
    .visually-hidden{position:absolute;left:-9999px;width:1px;height:1px;overflow:hidden}
  </style>
</head>
<body>
  <h1>PNG→JPG 変換（安全定義＋JSフォールバック）</h1>
  <div class="card">
    <div class="row">
      <button id="btnPickDir">フォルダを選ぶ</button>
      <input id="fallbackDir" type="file" webkitdirectory multiple accept="image/png" class="visually-hidden">
      <label class="secondary" for="fallbackDir" style="padding:10px 14px;border-radius:10px;cursor:pointer">フォルダ選択（互換）</label>
      <input id="pickFiles" type="file" multiple accept="image/png">
    </div>
    <div class="row">
      <label>JPEG 品質:<span id="lblQ" class="mono">90</span></label>
      <input id="quality" type="range" min="1" max="100" value="90" oninput="lblQ.textContent=this.value">
      <label>背景色:</label><input id="bg" type="color" value="#ffffff">
      <label><input id="includeOriginal" type="checkbox"> 変換元PNGもZIPに入れる</label>
      <span style="margin-left:auto">バッチ:<select id="batchSize"><option>10</option><option selected>25</option><option>50</option><option>100</option></select>件/回</span>
    </div>
    <div class="row">
      <button id="btnConvert" disabled>選択したPNGを変換 → ZIPダウンロード</button>
      <progress id="prog" max="100" value="0" style="visibility:hidden"></progress>
      <span id="status" class="mono"></span>
    </div>
  </div>

  <h3>ログ</h3>
  <div id="log" class="log mono"></div>

<script>
const logEl=document.getElementById('log'); function ts(){return new Date().toLocaleTimeString();}
function log(s){const line='['+ts()+'] '+s; logEl.textContent+=line+'\\n'; console.log(line); logEl.scrollTop=logEl.scrollHeight;}

let pickedEntries=[];
document.getElementById('pickFiles').addEventListener('change',e=>{
  const files=[...e.target.files].filter(f=>f.name.toLowerCase().endsWith('.png'));
  pickedEntries=files.map(f=>({name:f.name,path:f.name,file:f}));
  finalizeSelection();
});
document.getElementById('fallbackDir').addEventListener('change',e=>{
  const files=[...e.target.files];
  pickedEntries=files.filter(f=>f.name.toLowerCase().endsWith('.png')).map(f=>({name:f.name,path:f.webkitRelativePath||f.name,file:f}));
  finalizeSelection();
});
document.getElementById('btnPickDir').onclick=async()=>{
  if(!window.isSecureContext || !window.showDirectoryPicker){ log('ネイティブフォルダピッカー不可 → 互換ボタンを使用'); return; }
  try{
    log('フォルダピッカー表示…'); const dir=await window.showDirectoryPicker(); log('フォルダピッカー許可');
    pickedEntries=[];
    async function walk(h, prefix=""){
      for await(const [name,ent] of h.entries()){
        if(ent.kind==='file'){ if(name.toLowerCase().endsWith('.png')){const f=await ent.getFile(); pickedEntries.push({name,path:(prefix?prefix+'/':'')+name,file:f});}}
        else if(ent.kind==='directory'){ await walk(ent, (prefix?prefix+'/':'')+name); }
      }
    }
    await walk(dir,''); finalizeSelection();
  }catch(e){ log('フォルダ選択キャンセル/失敗: '+(e.message||e)); }
};
function finalizeSelection(){
  const mb=(pickedEntries.reduce((a,x)=>a+(x.file?.size||0),0)/1024/1024).toFixed(2);
  log('選択: '+pickedEntries.length+' PNG / 合計 '+mb+' MB');
  document.getElementById('btnConvert').disabled = pickedEntries.length===0;
  document.getElementById('status').textContent = pickedEntries.length? (pickedEntries.length+' ファイル ('+mb+' MB)') : '';
}

// Safer Step A
function fileToBase64_viaFileReader(file){
  return new Promise((resolve,reject)=>{
    const fr=new FileReader();
    fr.onerror=()=>reject(fr.error||new Error('FileReader error'));
    fr.onload=()=>{ try{ resolve((fr.result||'').toString().split(',')[1]||''); }catch(e){ reject(e);} };
    fr.readAsDataURL(file);
  });
}
async function fileToBase64_chunked(file){
  const buf=new Uint8Array(await file.arrayBuffer());
  const N=0x8000; const parts=[];
  for(let i=0;i<buf.length;i+=N){ parts.push(String.fromCharCode.apply(null, buf.subarray(i,i+N))); }
  return btoa(parts.join(''));
}

// --- Pyodide setup with safe "js." access and robust error logging ---
let pyReady=false, pyFailed=false;
async function ensurePyodide(){
  if(pyReady||pyFailed) return;
  log('Pyodide 読込開始…');
  const t0=performance.now();
  try{
    self.pyodide = await loadPyodide();
  }catch(e){
    log('Pyodide 読込失敗: '+(e.message||e)); pyFailed=true; return;
  }
  log('Pyodide 読込完了: '+((performance.now()-t0)|0)+'ms');
  log('Python 関数定義…');
  try{
    await pyodide.runPythonAsync(`
import json, base64, asyncio
import js
from pyodide.ffi import to_js
async def png_to_jpeg_b64(png_b64: str, bg_hex: str, quality: int) -> str:
    data = base64.b64decode(png_b64)
    u8 = js.Uint8Array.new(to_js(data))
    blob = js.Blob.new([u8], { "type": "image/png" })
    url = js.URL.createObjectURL(blob)
    img = js.Image.new()
    fut = asyncio.get_event_loop().create_future()
    def _ok(ev): fut.set_result(True)
    def _ng(ev): fut.set_exception(RuntimeError("image load error"))
    img.onload = _ok; img.onerror = _ng
    img.src = url
    await fut
    canvas = js.document.createElement("canvas")
    canvas.width = img.width; canvas.height = img.height
    ctx = canvas.getContext("2d")
    ctx.fillStyle = bg_hex; ctx.fillRect(0,0,canvas.width,canvas.height)
    ctx.drawImage(img,0,0)
    data_url = canvas.toDataURL("image/jpeg", max(0.01, min(1.0, quality/100)))
    js.URL.revokeObjectURL(url)
    return data_url.split(",",1)[1]
async def convert_many(files_json: str, quality: int, bg_hex: str) -> str:
    files = json.loads(files_json); out=[]
    for f in files:
        try:
            b64 = await png_to_jpeg_b64(f["data"], bg_hex, quality)
            p = f.get("path") or f["name"]
            p = (p.rsplit(".",1)[0] + ".jpg") if "." in p else (p + ".jpg")
            out.append({"path": p, "data": b64})
        except Exception as e:
            out.append({"path": f.get("path") or f["name"], "error": str(e)})
    return json.dumps(out)
    `);
  }catch(e){
    log('Python 定義失敗: '+(e.message||e));
    pyFailed=true; // fallback to JS-only path
    return;
  }
  log('Python 準備完了'); pyReady=true;
}

// JS-only fallback for conversion
async function convertBatchJS(batch, q, bg){
  const out=[];
  for(const f of batch){
    try{
      const bytes = Uint8Array.from(atob(f.data), c=>c.charCodeAt(0));
      const blob = new Blob([bytes], {type:'image/png'});
      const url = URL.createObjectURL(blob);
      const img = new Image();
      await new Promise((res,rej)=>{ img.onload=()=>res(); img.onerror=rej; img.src=url; });
      const canvas=document.createElement('canvas'); canvas.width=img.width; canvas.height=img.height;
      const ctx=canvas.getContext('2d'); ctx.fillStyle=bg; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0);
      const dataUrl=canvas.toDataURL('image/jpeg', Math.max(0.01, Math.min(1,q/100)));
      URL.revokeObjectURL(url);
      const p = (f.path||f.name).replace(/\.[^.]+$/i,'') + '.jpg';
      out.push({path:p, data:dataUrl.split(',')[1]});
    }catch(e){ out.push({path:f.path||f.name, error:(e.message||String(e))}); }
  }
  return out;
}

document.getElementById('btnConvert').onclick=async()=>{
  if(pickedEntries.length===0) return;
  const q=parseInt(document.getElementById('quality').value,10);
  const bg=document.getElementById('bg').value;
  const includeOriginal=document.getElementById('includeOriginal').checked;
  const batchSize=parseInt(document.getElementById('batchSize').value,10);
  const prog=document.getElementById('prog'); const status=document.getElementById('status');
  prog.style.visibility='visible'; prog.value=0;

  await ensurePyodide(); // may set pyFailed

  // Step A: read→b64 (safe)
  log('Step A: 読み込み→base64化（FileReader）…');
  const items=[];
  for(let i=0;i<pickedEntries.length;i++){
    const ent=pickedEntries[i];
    let b64='';
    try{ b64 = await fileToBase64_viaFileReader(ent.file); }
    catch(_){ log('  FileReader失敗 → chunked fallback'); b64 = await fileToBase64_chunked(ent.file); }
    items.push({name:ent.name, path:ent.path, data:b64});
    if((i+1)%25===0||i===pickedEntries.length-1){ status.textContent='準備中 '+(i+1)+'/'+pickedEntries.length; await new Promise(r=>setTimeout(r,0)); }
  }
  log('Step A 完了: '+items.length+' 件');

  // Step B: conversion (Python or JS fallback)
  const all=[]; const totalBatches=Math.ceil(items.length/batchSize); log('Step B: 変換開始（'+totalBatches+' バッチ, mode='+(pyFailed?'JS':'Python')+'）');
  for(let b=0;b<totalBatches;b++){
    const start=b*batchSize, end=Math.min(items.length,start+batchSize); const batch=items.slice(start,end);
    log('  バッチ '+(b+1)+'/'+totalBatches+' 件数='+batch.length);
    let res=[];
    if(!pyFailed){
      try{
        pyodide.globals.set('files_json', JSON.stringify(batch)); pyodide.globals.set('quality', q); pyodide.globals.set('bg_hex', bg);
        const outJson = await pyodide.runPythonAsync('await convert_many(files_json, quality, bg_hex)');
        res = JSON.parse(outJson);
      }catch(e){
        log('  Python 実行失敗 → JSに切替: '+(e.message||e)); pyFailed=true;
        res = await convertBatchJS(batch, q, bg);
      }
    }else{
      res = await convertBatchJS(batch, q, bg);
    }
    all.push(...res);
    prog.value=Math.round((end/items.length)*100); status.textContent='変換 '+end+'/'+items.length; await new Promise(r=>setTimeout(r,0));
  }
  const ok=all.filter(x=>!x.error), ng=all.filter(x=>x.error); if(ng.length){ log('失敗 '+ng.length+' 件 例: '+ng.slice(0,3).map(x=>x.path+':'+x.error).join('; ')); }

  // Step C: ZIP
  log('Step C: ZIP 生成 …');
  const zip=new JSZip();
  for(let i=0;i<ok.length;i++){ const r=ok[i]; zip.file(r.path, Uint8Array.from(atob(r.data), c=>c.charCodeAt(0))); }
  if(includeOriginal){ for(const ent of pickedEntries){ const buf=new Uint8Array(await ent.file.arrayBuffer()); zip.file(ent.path, buf);} }
  const blob=await zip.generateAsync({type:'blob'});
  const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='converted_jpegs.zip'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(a.href);
  prog.style.visibility='hidden'; status.textContent='完了: 成功 '+ok.length+', 失敗 '+ng.length; log('完了: 成功 '+ok.length+', 失敗 '+ng.length);
};
</script>
</body>
</html>
